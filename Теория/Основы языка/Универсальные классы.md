В C++, "универсальные классы" обычно называют "шаблонными классами". Шаблонные классы позволяют создавать классы, которые могут работать с разными типами данных. Это достигается путем использования шаблонных параметров, которые заменяются конкретными типами данных при создании экземпляров класса.

Шаблонные классы позволяют создавать более гибкий и повторно используемый код, поскольку один и тот же класс может быть использован с разными типами данных. Например, шаблонный класс вектора может быть использован для хранения и манипулирования векторами различных типов данных, таких как целые числа, вещественные числа, структуры и т.д.

Вот пример шаблонного класса в C++:
```c++
template <typename T>
class Vector {
private:
    T* data;
    int size;
public:
    Vector(int s) : size(s) {
        data = new T[size];
    }
    // ... другие методы класса ...
};
```
В этом примере, `T` является шаблонным параметром, который может быть заменен любым типом данных при создании экземпляра класса. Например, мы можем создать вектор из целых чисел следующим образом:
```c++
Vector<int> vec(10);
```
Или вектор из структур следующим образом:
```c++
struct Point {
    int x, y;
};
Vector<Point> points(10);
```
В обоих случаях, мы используем один и тот же шаблонный класс, но с разными типами данных.

Шаблонные классы в C++ имеют ряд особенностей, которые отличают их от обычных классов:

1. Шаблонные параметры: Шаблонные классы используют шаблонные параметры, которые заменяются конкретными типами данных при создании экземпляров класса. Шаблонные параметры могут быть типами данных, константами, другими шаблонами и т.д.
2. Инстанцирование шаблонов: Шаблонный класс является шаблоном для создания конкретных классов. Когда мы создаем экземпляр шаблонного класса с конкретным типом данных, это называется инстанцированием шаблона. Инстанцирование шаблона создает новый класс с заданным типом данных.
3. Отложенная инстанциация: Компилятор не создает код для шаблонного класса, пока он не используется с конкретным типом данных. Это называется отложенной инстанциацией. Отложенная инстанциация позволяет создавать более эффективный код, поскольку код для шаблонного класса генерируется только для тех типов данных, которые действительно используются.
4. Специализация шаблонов: Мы можем специализировать шаблонный класс для конкретного типа данных, чтобы предоставить более оптимальную реализацию для этого типа данных. Специализация шаблона позволяет нам изменить поведение шаблонного класса для конкретного типа данных.
5. Шаблонные функции-члены: Шаблонные классы могут иметь шаблонные функции-члены, которые также используют шаблонные параметры. Шаблонные функции-члены позволяют создавать более гибкий и повторно используемый код.
6. Шаблонные аргументы по умолчанию: Шаблонные классы могут иметь шаблонные аргументы по умолчанию, которые используются, если мы не предоставляем явный аргумент при создании экземпляра класса.

Шаблонные классы позволяют создавать более гибкий и повторно используемый код, поскольку один и тот же класс может быть использован с разными типами данных. Однако, они также могут быть более сложными в использовании и отладке, поскольку они требуют более глубокого понимания шаблонов и их особенностей.

#cpp #theory